(def ADD-extended-register
    "s 0 0 01011 00 1 mmmmm ooo iii nnnnn ddddd"
    "add $r1$rd, $r1$rn, $r2$rm, $extend #$imm"
    (names (size s) (rm m) (option o) (imm i) (rn n) (rd d))
    (block
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (== (& option 0b011) 0b011) "X" "W"))
        (let extend (if (== size 0)
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "LSL"
                0b011 "UXTX"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "UXTW"
                0b011 "LSL"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX"))))
    (if (== size 0)
        (let m (gpr32 rm)
            (= (gpr-or-sp32 rd) (+ (gpr-or-sp32 rn) (<< (match option
                0b000 (& m 0xFF)
                0b001 (& m 0xFFFF)
                0b100 (cast (signext (cast m u8) i32) u32)
                0b101 (cast (signext (cast m u16) i32) u32)
                m) imm))))
        (if (== (& option 0b011) 0b011)
            (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) (<< (gpr64 rm) imm)))
            (let m (cast (gpr32 rm) u64)
                (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) (<< (match option
                    0b000 (& m 0xFF)
                    0b001 (& m 0xFFFF)
                    0b010 (& m 0xFFFFFFFF)
                    0b100 (cast (signext (cast m u8) i64) u64)
                    0b101 (cast (signext (cast m u16) i64) u64)
                    0b110 (cast (signext m i64) u64)
                    m) imm)))))))

(def ADD-immediate
    "f 0 0 10001 0s iiiiiiiiiiii nnnnn ddddd"
    "add $r$rd, $r$rn, #$imm, LSL #$shift"
    (names (size f) (sh s) (imm i) (rd d) (rn n))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (if (== sh 0) 0 12))
        (let simm (<< imm shift)))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (+ (gpr-or-sp32 rn) simm))
        (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) simm))))

(def ADD-shifted-register
    "f 0 0 01011 ss 0 mmmmm iiiiii nnnnn ddddd"
    "add $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (imm i) (rd d) (rn n) (rm m))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (match shift
            0b00 "LSL"
            0b01 "LSR"
            0b10 "ASR"
            (unimplemented))))
    (if (== size 0)
        (let b (gpr-or-sp32 rm)
            (= (gpr-or-sp32 rd) (+ (gpr-or-sp32 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i32) imm) u32)
                (unimplemented)))))
        (let b (gpr-or-sp64 rm)
            (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i64) imm) u64)
                (unimplemented)))))))

(def ADDS-immediate
    "f 0 1 10001 0s iiiiiiiiiiii nnnnn ddddd"
    "adds $r$rd, $r$rn, #$imm, LSL #$shift"
    (names (size f) (sh s) (imm i) (rd d) (rn n))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (if (== sh 0) 0 12))
        (let simm (<< imm shift)))
    (if (== size 0)
        (= (gpr32 rd) (add-with-carry-set-nzcv (gpr-or-sp32 rn) simm 0))
        (= (gpr64 rd) (add-with-carry-set-nzcv (gpr-or-sp64 rn) simm 0))))

(def ADRP
    "1 ll 10000 iiiiiiiiiiiiiiiiiii ddddd"
    "adrp X$rd, #$addr"
    (names (immlo l) (immhi i) (rd d))
    (block
        (let imm (signext (| (<< (cast immhi u33) 14) (<< (cast immlo u14) 12)) i64))
        (let addr (+ (<< (>> (pc) 12) 12) imm)))
    (= (gpr64 rd) addr))

(def AND-immediate
    "f 00 100100 u iiiiii ssssss nnnnn ddddd"
    "and $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr i) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (& (gpr32 rn) (cast imm u32)))
        (= (gpr-or-sp64 rd) (& (gpr64 rn) imm))))

(def AND-shifted-register
    "f 00 01010 ss 0 mmmmm iiiiii nnnnn ddddd"
    "and $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (match shift
            0b00 "LSL"
            0b01 "LSR"
            0b10 "ASR"
            "ROR")))
    (if (== size 0)
        (let b (gpr32 rm)
            (= (gpr32 rd) (& (gpr32 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i32) imm) u32)
                (>>> b imm)))))
        (let b (gpr64 rm)
            (= (gpr64 rd) (& (gpr64 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i64) imm) u64)
                (>>> b imm)))))))

(def ANDS-immediate
    "f 11 100100 u rrrrrr ssssss nnnnn ddddd"
    "ands $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr r) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (let result (& (gpr32 rn) imm)
            (= (gpr32 rd) result)
            (= (nzcv n) (>> result 31))
            (= (nzcv z) (== result 0))
            (= (nzcv c) 0)
            (= (nzcv v) 0))
        (let result (& (gpr64 rn) imm)
            (= (gpr64 rd) result)
            (= (nzcv n) (>> result 63))
            (= (nzcv z) (== result 0))
            (= (nzcv c) 0)
            (= (nzcv v) 0))))

(def B
    "0 00101 iiiiiiiiiiiiiiiiiiiiiiiiii"
    "b #$addr"
    (names (imm i))
    (let addr (+ (pc) (signext (<< (cast imm u28) 2) i64)))
    (branch addr))

(def B.cond
    "0101010 0 iiiiiiiiiiiiiiiiiii 0 cccc"
    "b.$condstr #$addr"
    (names (imm i) (cond c))
    (block
        (let addr (+ (pc) (signext (<< (cast imm u21) 2) i64)))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (block
        (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1))
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (branch addr)
            (branch-default))))

(def BFM
    "f 01 100110 o pppppp ssssss nnnnn ddddd"
    "bfm $r$rd, $r$rn, #$immr, #$imms"
    (names (N o) (size f) (immr p) (imms s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (block
            (let dst (gpr32 rd))
            (let src (gpr32 rn))
            (let wmask (cast (make-wmask N imms immr 0 32) u32))
            (let tmask (cast (make-tmask N imms immr 0 32) u32))
            (let bot (| (& dst (~ wmask)) (& (>>> src immr) wmask)))
            (= (gpr32 rd) (& bot tmask)))
        (block
            (let dst (gpr32 rd))
            (let src (gpr64 rn))
            (let wmask (make-wmask N imms immr 0 64))
            (let tmask (make-tmask N imms immr 0 64))
            (let bot (| (& dst (~ wmask)) (& (>>> src immr) wmask)))
            (= (gpr64 rd) (| (& dst (~ tmask)) (& bot tmask))))))

(def BIC
    "f 00 01010 ss 1 mmmmm iiiiii nnnnn ddddd"
    "bic $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (match shift
            0b00 "LSL"
            0b01 "LSR"
            0b10 "ASR"
            "ROR")))
    (if (== size 0)
        (let b (gpr32 rm)
            (= (gpr32 rd) (& (gpr32 rn) (~ (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i32) imm) u32)
                (>>> b imm))))))
        (let b (gpr64 rm)
            (= (gpr64 rd) (& (gpr64 rn) (~ (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i64) imm) u64)
                (>>> b imm))))))))

(def BL
    "1 00101 iiiiiiiiiiiiiiiiiiiiiiiiii"
    "bl #$addr"
    (names (imm i))
    (block
        (let offset (signext (<< (cast imm u28) 2) i64))
        (let addr (+ (pc) offset)))
    (block
        (= (gpr64 30) (+ (pc) 4))
        (branch addr)))

(def BLR
    "1101011 0 0 01 11111 0000 0 0 nnnnn 00000"
    "blr X$rn"
    (names (rn n))
    (block)
    (block
        (= (gpr64 30) (+ (pc) 4))
        (branch (gpr64 rn))))

(def BR
    "1101011 0 0 00 11111 0000 0 0 nnnnn 00000"
    "br X$rn"
    (names (rn n))
    (block)
    (branch (gpr64 rn)))

(def CBNZ
    "s 011010 1 iiiiiiiiiiiiiiiiiii ttttt"
    "cbnz $r$rs, #$addr"
    (names (size s) (imm i) (rs t))
    (block
         (let r (if (== size 0) "W" "X"))
         (let addr (+ (pc) (signext (cast (<< imm 2) u21) i64))))
    (if (== size 0)
        (if (!= (gpr32 rs) (cast 0 u32))
            (branch addr)
            (branch-default))
        (if (!= (gpr64 rs) (cast 0 u64))
            (branch addr)
            (branch-default))))

(def CBZ
    "s 011010 0 iiiiiiiiiiiiiiiiiii ttttt"
    "cbz $r$rs, #$addr"
    (names (size s) (imm i) (rs t))
    (block
         (let r (if (== size 0) "W" "X"))
         (let addr (+ (pc) (signext (cast (<< imm 2) u21) i64))))
    (if (== size 0)
        (if (== (gpr32 rs) (cast 0 u32))
            (branch addr)
            (branch-default))
        (if (== (gpr64 rs) (cast 0 u64))
            (branch addr)
            (branch-default))))

(def CCMP-immediate
    "s 1 1 11010010 iiiii cccc 1 0 nnnnn 0 zzzz"
    "ccmp $r$rn, #$imm, #$nzcv, $condstr"
    (names (size s) (imm i) (cond c) (rn n) (nzcv z))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 31) (add-with-carry-set-nzcv (gpr32 rn) (~ (cast imm u32)) 1))
                (= (gpr64 31) (add-with-carry-set-nzcv (gpr64 rn) (~ (cast imm u64)) 1)))
            (= (nzcv) (<< (cast nzcv u64) 28)))))

(def CCMP-register
    "s 1 1 11010010 mmmmm cccc 0 0 nnnnn 0 zzzz"
    "ccmp $r$rn, $r$rm, #$nzcv, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (nzcv z))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 31) (add-with-carry-set-nzcv (gpr32 rn) (~ (gpr32 rm)) 1))
                (= (gpr64 31) (add-with-carry-set-nzcv (gpr64 rn) (~ (gpr64 rm)) 1)))
            (= (nzcv) (<< (cast nzcv u64) 28)))))

(def CLZ
    "s 1 0 11010110 00000 00010 0 nnnnn ddddd"
    "clz $r$rd, $r$rn"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (count-leading-zeros (gpr32 rn)))
        (= (gpr64 rd) (count-leading-zeros (gpr64 rn)))))

(def CSEL
    "s 0 0 11010100 mmmmm cccc 0 0 nnnnn ddddd"
    "csel $r$rd, $r$rn, $r$rm, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rn))
                (= (gpr64 rd) (gpr64 rn)))
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rm))
                (= (gpr64 rd) (gpr64 rm))))))

(def CSINC
    "s 0 0 11010100 mmmmm cccc 0 1 nnnnn ddddd"
    "csinc $r$rd, $r$rn, $r$rm, $condstr"
    (names (size s) (rm m) (cond c) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let condstr (match cond
            0b0000 "EQ" 0b0001 "NE"
            0b0010 "CS" 0b0011 "CC"
            0b0100 "MI" 0b0101 "PL"
            0b0110 "VS" 0b0111 "VC"
            0b1000 "HI" 0b1001 "LS"
            0b1010 "GE" 0b1011 "LT"
            0b1100 "GT" 0b1101 "LE"
            "AL")))
    (let result (match (>> cond 1)
            0b000 (nzcv z)
            0b001 (nzcv c)
            0b010 (nzcv n)
            0b011 (nzcv v)
            0b100 (& (nzcv c) (! (nzcv z)))
            0b101 (== (nzcv n) (nzcv v))
            0b110 (& (== (nzcv n) (nzcv v)) (! (nzcv z)))
            1)
        (if (if (& (& cond 1) (!= cond 0b1111)) (! result) result)
            (if (== size 0)
                (= (gpr32 rd) (gpr32 rn))
                (= (gpr64 rd) (gpr64 rn)))
            (if (== size 0)
                (= (gpr32 rd) (+ (gpr32 rm) (cast 1 u32)))
                (= (gpr64 rd) (+ (gpr64 rm) 1))))))

(def DUP-general
    "0 p 0 01110000 iiiii 0 0001 1 nnnnn ddddd"
    "dup V$rd.$T, $r$rn"
    (names (Q p) (imm i) (rn n) (rd d))
    (block
        (let size (if (== (& imm 0b01111) 0) (unimplemented) (if (== (& imm 0b01111) 0b01000) 64 32)))
        (let r (if (== size 64) "X" "W"))
        (let T
            (if (== (& imm 0b01111) 0) (unimplemented)
            (if (== (& imm 0b00001) 0b0001) (if Q "16B" "8B")
            (if (== (& imm 0b00011) 0b0010) (if Q "8H" "4H")
            (if (== (& imm 0b00111) 0b0100) (if Q "4S" "2S")
            (if Q "2D" (unimplemented))))))))
    (let src (gpr64 rn)
        (= (vec rd)
            (if (== (& imm 0b00001) 0b0001) (if Q
                (vector-all (cast src u8))
                (vector-zero-top (vector-all (cast src u8))))
            (if (== (& imm 0b00011) 0b0010) (if Q
                (vector-all (cast src u16))
                (vector-zero-top (vector-all (cast src u16))))
            (if (== (& imm 0b00111) 0b0100) (if Q
                (vector-all (cast src u32))
                (vector-zero-top (vector-all (cast src u32))))
            (if Q (vector-all src) (unimplemented))))))))

(def EOR-immediate
    "f 10 100100 u iiiiii ssssss nnnnn ddddd"
    "and $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr i) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (^ (gpr32 rn) (cast imm u32)))
        (= (gpr-or-sp64 rd) (^ (gpr64 rn) imm))))

(def EOR-shifted-register
    "f 10 01010 ss 0 mmmmm iiiiii nnnnn ddddd"
    "eor $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (match shift
            0b00 "LSL"
            0b01 "LSR"
            0b10 "ASR"
            "ROR")))
    (if (== size 0)
        (let b (gpr32 rm)
            (= (gpr32 rd) (^ (gpr32 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i32) imm) u32)
                (>>> b imm)))))
        (let b (gpr64 rm)
            (= (gpr64 rd) (^ (gpr64 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i64) imm) u64)
                (>>> b imm)))))))

(def LDARB
    "00 001000 1 1 0 11111 1 11111 nnnnn ttttt"
    "ldarb W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (= (gpr64 rt) (cast (load address u8) u64)))) 

(def LDAXB
    "1s 001000 0 1 0 11111 1 11111 nnnnn ttttt"
    "ldaxb W$rt, [X$rn]"
    (names (size s) (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (if (== size 0)
            (= (gpr32 rt) (load address u32))
            (= (gpr64 rt) (load address u64))))) 

(def LDP-immediate-postindex
    "s0 101 0 001 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn], #$simm"
    (names (size s) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (gpr-or-sp64 rn)
        (if (== size 0)
            (block
                (= (gpr32 rt1) (load address u32))
                (= (gpr32 rt2) (load (+ address 4) u32)))
            (block
                (= (gpr64 rt1) (load address u64))
                (= (gpr64 rt2) (load (+ address 8) u64))))
        (= (gpr-or-sp64 rn) (+ address simm))))

(def LDP-immediate-signed-offset
    "s0 101 0 010 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn, #$simm]"
    (names (size s) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (+ (gpr-or-sp64 rn) simm)
        (if (== size 0)
            (block
                (= (gpr32 rt1) (load address u32))
                (= (gpr32 rt2) (load (+ address 4) u32)))
            (block
                (= (gpr64 rt1) (load address u64))
                (= (gpr64 rt2) (load (+ address 8) u64))))))

(def LDP-simd-postindex
    "oo 101 1 001 1 iiiiiii ppppp nnnnn ttttt"
    "ldp $r$rt1, $r$rt2, [X$rn], #$simm"
    (names (opc o) (imm i) (rt2 p) (rn n) (rt1 t))
    (block
        (let r (match opc 0b00 "S" 0b01 "D" "Q")) 
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 4))))
    (let address (gpr-or-sp64 rn)
        (match opc
            0b00 (block
                (= (vec-s rt1) (load address f32))
                (= (vec-s rt2) (load (+ address 4) f32)))
            0b01 (block
                (= (vec-d rt1) (load address f64))
                (= (vec-d rt2) (load (+ address 8) f64)))
            (block
                (= (vec rt1) (load address vec))
                (= (vec rt2) (load (+ address 16) vec))))
        (= (gpr-or-sp64 rn) (+ address simm))))

(def LDR-immediate-preindex
    "1s 111 0 00 01 0 iiiiiiiii 11 nnnnn ddddd"
    "ldr $r$rd, [X$rn, #$imm]!"
    (names (size s) (rawimm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (signext rawimm i64)))
    (let address (+ (gpr-or-sp64 rn) imm)
        (if (== size 0)
            (= (gpr32 rd) (load address u32))
            (= (gpr64 rd) (load address u64)))
        (= (gpr-or-sp64 rn) address)))

(def LDR-immediate-postindex
    "1s 111 0 00 01 0 iiiiiiiii 01 nnnnn ddddd"
    "ldr $r$rd, [X$rn], #$imm"
    (names (size s) (rawimm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (signext rawimm i64)))
    (block
        (if (== size 0)
            (= (gpr32 rd) (load (gpr-or-sp64 rn) u32))
            (= (gpr64 rd) (load (gpr-or-sp64 rn) u64)))
        (= (gpr-or-sp64 rn) (+ (gpr-or-sp64 rn) imm))))

(def LDR-immediate-unsigned-offset
    "1s 111 0 01 01 iiiiiiiiiiii nnnnn ddddd"
    "ldr $r$rd, [X$rn, #$imm]"
    (names (size s) (rawimm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (<< rawimm (if (== size 0) 2 3))))
    (if (== size 0)
        (= (gpr32 rd) (load (+ (gpr-or-sp64 rn) imm) u32))
        (= (gpr64 rd) (load (+ (gpr-or-sp64 rn) imm) u64))))

(def LDR-register
    "1f 111 0 00 01 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldr $r1$rt, [X$rn, $r2$rm, $extend $amount]"
    (names (size f) (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (& option 1) "X" "W"))
        (let amount (if (== scale 0) 0 (if (== size 0) 2 3)))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            "LSL")))
    (let offset (<< (if (== option 0b110)
            (cast (signext (gpr32 rm) i64) u64)
            (if (& option 1)
                (gpr64 rm)
                (cast (gpr32 rm) u64))) amount)
        (if (== size 0)
            (= (gpr32 rt) (load (+ (gpr-or-sp64 rn) offset) u32))
            (= (gpr64 rt) (load (+ (gpr-or-sp64 rn) offset) u64)))))

(def LDRB-immediate-preindex
    "00 111 0 00 01 0 iiiiiiiii 11 nnnnn ttttt"
    "ldrb W$rt, [X$rn, #$imm]!"
    (names (rawimm i) (rn n) (rt t))
    (let imm (signext rawimm i64))
    (let address (+ (gpr-or-sp64 rn) imm)
        (= (gpr32 rt) (cast (load address u8) u32))
        (= (gpr-or-sp64 rn) address)))

(def LDRB-immediate-postindex
    "00 111 0 00 01 0 iiiiiiiii 01 nnnnn ttttt"
    "ldrb W$rt, [X$rn], #$imm"
    (names (rawimm i) (rn n) (rt t))
    (let imm (signext rawimm i64))
    (block
        (= (gpr32 rt) (cast (load (gpr-or-sp64 rn) u8) u32))
        (= (gpr-or-sp64 rn) (+ (gpr-or-sp64 rn) imm))))

(def LDRB-immediate-unsigned-offset
    "00 111 0 01 01 iiiiiiiiiiii nnnnn ttttt"
    "ldrb W$rt, [X$rn, #$imm]"
    (names (imm i) (rt t) (rn n))
    (block)
    (= (gpr64 rt) (cast (load (+ (gpr-or-sp64 rn) imm) u8) u64)))

(def LDRB-register
    "00 111 0 00 01 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldrb W$rt, [X$rn, $r$rm, $extend $amount]"
    (names (rm m) (option o) (amount s) (rn n) (rt t))
    (block
        (let r (if (& option 1) "X" "W"))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            "LSL")))
    (unimplemented))

(def LDRH-immediate-unsigned-offset
    "01 111 0 01 01 iiiiiiiiiiii nnnnn ttttt"
    "ldrh W$rt, [X$rn, #$imm]"
    (names (rawimm i) (rt t) (rn n))
    (let imm (<< rawimm 1))
    (= (gpr64 rt) (cast (load (+ (gpr-or-sp64 rn) imm) u16) u64)))

(def LDRSW-immediate-unsigned-offset
    "10 111 0 01 10 iiiiiiiiiiii nnnnn ttttt"
    "ldrsw X$rt, [X$rn, #$imm]"
    (names (rawimm i) (rt t) (rn n))
    (let imm (<< rawimm 2))
    (= (gpr64 rt) (cast (signext (load (+ (gpr-or-sp64 rn) imm) u32) i64) u64)))

(def LDRSW-register
    "10 111 0 00 10 1 mmmmm ooo s 10 nnnnn ttttt"
    "ldrsw X$rt, [X$rn, $r$rm, $extend $amount]"
    (names (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let r (if (& option 1) "X" "W"))
        (let amount (if (== scale 0) 0 2))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            "LSL")))
    (let offset (<< (if (== option 0b110)
            (cast (signext (gpr32 rm) i64) u64)
            (if (& option 1)
                (gpr64 rm)
                (cast (gpr32 rm) u64))) amount)
        (= (gpr64 rt) (cast (signext (load (+ (gpr-or-sp64 rn) offset) u32) i64) u64))))

(def LDUR
    "1s 111 0 00 01 0 iiiiiiiii 00 nnnnn ttttt"
    "ldur $r$rd, [X$rn, #$imm]"
    (names (size s) (rawimm i) (rn n) (rd t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (signext rawimm i64)))
    (if (== size 0)
        (= (gpr32 rd) (load (+ (gpr-or-sp64 rn) imm) u32))
        (= (gpr64 rd) (load (+ (gpr-or-sp64 rn) imm) u64))))

(def LDURB
    "00 111 0 00 01 0 iiiiiiiii 00 nnnnn ttttt"
    "ldurb W$rd, [X$rn, #$imm]"
    (names (rawimm i) (rn n) (rd t))
    (let imm (signext rawimm i64))
    (= (gpr64 rd) (cast (load (+ (gpr-or-sp64 rn) imm) u8) u64)))

(def LSRV
    "s 0 0 11010110 mmmmm 0010 01 nnnnn ddddd"
    "lsrv $r$rd, $r$rn, $r$rm"
    (names (size s) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (>> (gpr32 rn) (gpr32 rm)))
        (= (gpr64 rd) (>> (gpr64 rn) (gpr64 rm)))))

(def MADD
    "s 00 11011 000 mmmmm 0 aaaaa nnnnn ddddd"
    "madd $r$rd, $r$rn, $r$rm, $r$ra"
    (names (size s) (rm m) (ra a) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (+ (* (gpr32 rn) (gpr32 rm)) (gpr32 ra)))
        (= (gpr64 rd) (+ (* (gpr64 rn) (gpr64 rm)) (gpr64 ra)))))

(def MOVK
    "s 11 100101 hh iiiiiiiiiiiiiiii ddddd"
    "movk $r$rd, #$imm, LSL #$shift"
    (names (size s) (imm i) (rd d) (hw h))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (<< hw 4)))
    (if (== size 0)
        (= (gpr32 rd) (| (& (gpr32 rd) (>>> (cast -1 u32) (- 16 shift))) (<< (cast imm u32) shift)))
        (= (gpr64 rd) (| (& (gpr64 rd) (>>> (cast -1 u64) (- 16 shift))) (<< (cast imm u64) shift)))))

(def MOVN
    "s 00 100101 hh iiiiiiiiiiiiiiii ddddd"
    "movn $r$rd, #$imm, LSL #$shift"
    (names (size s) (imm i) (rd d) (hw h))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (<< hw 4)))
    (if (== size 0)
        (= (gpr32 rd) (~ (<< (cast imm u32) shift)))
        (= (gpr64 rd) (~ (<< (cast imm u64) shift)))))

(def MOVZ
    "s 10 100101 hh iiiiiiiiiiiiiiii ddddd"
    "movz $r$rd, #$imm, LSL #$shift"
    (names (size s) (imm i) (rd d) (hw h))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (<< hw 4)))
    (if (== size 0)
        (= (gpr32 rd) (<< (cast imm u32) shift))
        (= (gpr64 rd) (<< (cast imm u64) shift))))

(def MRS
    "1101010100 1 1 o ppp nnnn mmmm qqq ttttt"
    "mrs S$op0 $op1 $cn $cm $op2, X$rt"
    (names (op0 o) (op1 p) (cn n) (cm m) (op2 q) (rt t))
    (block)
    (= (gpr64 rt) (sr op0 op1 cn cm op2)))

(def MSR-register
    "1101010100 0 1 o ppp nnnn mmmm qqq ttttt"
    "msr S$op0 $op1 $cn $cm $op2, X$rt"
    (names (op0 o) (op1 p) (cn n) (cm m) (op2 q) (rt t))
    (block)
    (= (sr op0 op1 cn cm op2) (gpr64 rt)))

(def MSUB
    "s 00 11011 000 mmmmm 1 aaaaa nnnnn ddddd"
    "msub $r$rd, $r$rn, $r$rm, $r$ra"
    (names (size s) (rm m) (ra a) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (- (gpr32 ra) (* (gpr32 rn) (gpr32 rm))))
        (= (gpr64 rd) (- (gpr64 ra) (* (gpr64 rn) (gpr64 rm))))))

(def ORR-immediate
    "f 01 100100 u iiiiii ssssss nnnnn ddddd"
    "orr $r$rd, $r$rn, #$imm"
    (names (size f) (up u) (immr i) (imms s) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let imm (make-wmask up imms immr 1 (if (== size 0) 32 64))))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (| (gpr32 rn) (cast imm u32)))
        (= (gpr-or-sp64 rd) (| (gpr64 rn) imm))))

(def ORR-shifted-register
    "f 01 01010 ss 0 mmmmm iiiiii nnnnn ddddd"
    "orr $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (rm m) (imm i) (rn n) (rd d))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shiftstr (match shift
                    0b00 "LSL"
                    0b01 "LSR"
                    0b10 "ASR"
                    "ROR")))
    (if (== size 0)
            (let b (gpr32 rm)
                (= (gpr32 rd) (| (gpr32 rn) (match shift
                    0b00 (<< b imm)
                    0b01 (>> b imm)
                    0b10 (cast (>> (cast b i32) imm) u32)
                    (>>> b imm)))))
            (let b (gpr64 rm)
                (= (gpr64 rd) (| (gpr64 rn) (match shift
                    0b00 (<< b imm)
                    0b01 (>> b imm)
                    0b10 (cast (>> (cast b i64) imm) u64)
                    (>>> b imm)))))))

(def RBIT
    "s 1 0 11010110 00000 0000 00 nnnnn ddddd"
    "rbit $r$rd, $r$rn"
    (names (size s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (= (gpr32 rd) (reverse-bits (gpr32 rn)))
        (= (gpr64 rd) (reverse-bits (gpr64 rn)))))

(def RET
    "1101011 0 0 10 11111 0000 0 0 nnnnn 00000"
    "ret X$rn"
    (names (rn n))
    (block)
    (branch (gpr64 rn)))

(def SBFM
    "f 00 100110 o pppppp ssssss nnnnn ddddd"
    "sbfm $r$rd, $r$rn, #$immr, #$imms"
    (names (N o) (size f) (immr p) (imms s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (block
            (let src (gpr32 rn))
            (let wmask (cast (make-wmask N imms immr 0 32) u32))
            (let tmask (cast (make-tmask N imms immr 0 32) u32))
            (let bot (& (>>> src immr) wmask))
            (let top (- (cast 0 u32) (& (>> src imms) 1)))
            (= (gpr32 rd) (| (& top (~ tmask)) (& bot tmask))))
        (block
            (let src (gpr64 rn))
            (let wmask (make-wmask N imms immr 0 64))
            (let tmask (make-tmask N imms immr 0 64))
            (let bot (& (>>> src immr) wmask))
            (let top (- (cast 0 u64) (& (>> src imms) 1)))
            (= (gpr64 rd) (| (& top (~ tmask)) (& bot tmask))))))

(def STLRB
    "00 001000 1 0 0 11111 1 11111 nnnnn ttttt"
    "stlrb W$rt, [X$rn]"
    (names (rn n) (rt t))
    (block)
    (let address (gpr-or-sp64 rn)
        (store address (cast (gpr32 rt) u8))))

(def STLXR
    "1f 001000 0 0 0 sssss 1 11111 nnnnn ttttt"
    "stlxr W$rs, $r$rt, [X$rn]"
    (names (size f) (rs s) (rn n) (rt t))
    (let r (if (== size 0) "W" "X"))
    (let address (gpr-or-sp64 rn)
        (if (== size 0)
            (store address (gpr32 rt))
            (store address (gpr64 rt)))
        (= (gpr32 rs) 0)))

(def STP-postindex
    "s0 101 0 001 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd], #$simm"
    (names (size s) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (gpr-or-sp64 rd)
        (if (== size 0)
            (block
                (store address (gpr32 rt1))
                (store (+ address 4) (gpr32 rt2)))
            (block
                (store address (gpr64 rt1))
                (store (+ address 8) (gpr64 rt2))))
        (= (gpr-or-sp64 rd) (+ address simm))))

(def STP-preindex
    "s0 101 0 011 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]!"
    (names (size s) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (if (== size 0)
            (block
                (store address (gpr32 rt1))
                (store (+ address 4) (gpr32 rt2)))
            (block
                (store address (gpr64 rt1))
                (store (+ address 8) (gpr64 rt2))))
        (= (gpr-or-sp64 rd) address)))

(def STP-signed-offset
    "s0 101 0 010 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]"
    (names (size s) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (if (== size 0) "W" "X"))
        (let simm (<< (signext imm i64) (if (== size 0) 2 3))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (if (== size 0)
            (block
                (store address (gpr32 rt1))
                (store (+ address 4) (gpr32 rt2)))
            (block
                (store address (gpr64 rt1))
                (store (+ address 8) (gpr64 rt2))))))

(def STP-simd-preindex
    "oo 101 1 011 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]!"
    (names (opc o) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (match opc 0b00 "S" 0b01 "D" 0b10 "Q" (unimplemented)))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 0b10 4 (unimplemented)))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (match opc
            0b00 (block
                (store address (vec-s rt1))
                (store (+ address 4) (vec-s rt2)))
            0b01 (block
                (store address (vec-d rt1))
                (store (+ address 8) (vec-d rt2)))
            0b10 (block
                (store address (vec rt1))
                (store (+ address 16) (vec rt2)))
            (unimplemented))
        (= (gpr-or-sp64 rd) address)))

(def STP-simd-signed-offset
    "oo 101 1 010 0 iiiiiii ppppp nnnnn ttttt"
    "stp $r$rt1, $r$rt2, [X$rd, #$simm]"
    (names (opc o) (imm i) (rd n) (rt1 t) (rt2 p))
    (block
        (let r (match opc 0b00 "S" 0b01 "D" 0b10 "Q" (unimplemented)))
        (let simm (<< (signext imm i64) (match opc 0b00 2 0b01 3 0b10 4 (unimplemented)))))
    (let address (+ (gpr-or-sp64 rd) simm)
        (match opc
            0b00 (block
                (store address (vec-s rt1))
                (store (+ address 4) (vec-s rt2)))
            0b01 (block
                (store address (vec-d rt1))
                (store (+ address 8) (vec-d rt2)))
            0b10 (block
                (store address (vec rt1))
                (store (+ address 16) (vec rt2)))
            (unimplemented))))

(def STR-immediate-postindex
	"1s 111 0 00 00 0 iiiiiiiii 01 nnnnn ttttt"
	"str $r$rs, [X$rd], #$simm"
	(names (size s) (imm i) (rd n) (rs t))
	(block
		(let r (if (== size 0) "W" "X"))
		(let simm (signext imm i64)))
	(let address (gpr-or-sp64 rd)
		(if (== size 0)
			(store address (gpr32 rs))
			(store address (gpr64 rs)))
		(= (gpr-or-sp64 rd) (+ address simm))))

(def STR-immediate-preindex
	"1s 111 0 00 00 0 iiiiiiiii 11 nnnnn ttttt"
	"str $r$rs, [X$rd, #$simm]!"
	(names (size s) (imm i) (rd n) (rs t))
	(block
		(let r (if (== size 0) "W" "X"))
		(let simm (signext imm i64)))
	(let address (+ (gpr-or-sp64 rd) simm)
		(if (== size 0)
			(store address (gpr32 rs))
			(store address (gpr64 rs)))
		(= (gpr-or-sp64 rd) address)))

(def STR-immediate-unsigned-offset
    "1s 111 0 01 00 iiiiiiiiiiii nnnnn ttttt"
    "str $r$rs, [X$rd, #$pimm]"
    (names (size s) (imm i) (rd n) (rs t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let pimm (<< (cast imm u64) (if (== size 0) 2 3))))
    (if (== size 0)
        (store (+ (gpr-or-sp64 rd) pimm) (gpr32 rs))
        (store (+ (gpr-or-sp64 rd) pimm) (gpr64 rs))))

(def STR-register
    "1f 111 0 00 00 1 mmmmm ooo s 10 nnnnn ttttt"
    "str $r1$rt, [X$rn, $r2$rm, $extend $amount]"
    (names (size f) (rm m) (option o) (scale s) (rn n) (rt t))
    (block
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (& option 1) "X" "W"))
        (let amount (if (== scale 0) 0 (if (== size 0) 2 3)))
        (let extend (match option
            0b010 "UXTW"
            0b110 "SXTW"
            0b111 "SXTX"
            "LSL")))
    (let offset (<< (if (== option 0b110)
            (cast (signext (gpr32 rm) i64) u64)
            (if (& option 1)
                (gpr64 rm)
                (cast (gpr32 rm) u64))) amount)
        (if (== size 0)
            (store (+ (gpr-or-sp64 rn) offset) (gpr32 rt))
            (store (+ (gpr-or-sp64 rn) offset) (gpr64 rt)))))

(def STRB-immediate-unsigned-offset
    "00 111 0 01 00 iiiiiiiiiiii nnnnn ttttt"
    "strb W$rt, [X$rn, #$imm]"
    (names (imm i) (rn n) (rt t))
    (block)
    (store (+ (gpr-or-sp64 rn) imm) (cast (gpr64 rt) u8)))

(def STRB-register
    "00 111 0 00 00 1 mmmmm ooo s 10 nnnnn ttttt"
    "strb W$rt, [X$rn, $r$rm, $str $amount"
    (names (rm m) (option o) (amount s) (rn n) (rt t))
    (let r (if (& option 1) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (unimplemented))

(def STRH-immediate-unsigned-offset
    "01 111 0 01 00 iiiiiiiiiiii nnnnn ttttt"
    "strh W$rt, [X$rn, #$imm]"
    (names (imm i) (rn n) (rt t))
    (block)
    (store (+ (gpr-or-sp64 rn) imm) (cast (gpr64 rt) u16)))

(def STRH-register
    "01 111 0 00 00 1 mmmmm ooo s 10 nnnnn ttttt"
    "strh W$rt, [X$rn, $r$rm, $str $amount"
    (names (rm m) (option o) (amount s) (rn n) (rt t))
    (let r (if (& option 1) "X" "W")
        (let str (match option
            0b010 "UXTW"
            0b011 "LSL"
            0b110 "SXTW"
            0b111 "SXTX"
            (unimplemented))))
    (unimplemented))

(def STUR
    "1s 111 0 00 00 0 iiiiiiiii 00 nnnnn ttttt"
    "stur $r$rt, [X$rn, #$offset]"
    (names (size s) (imm i) (rn n) (rt t))
    (block
        (let r (if (== size 0) "W" "X"))
        (let offset (signext imm i64)))
    (if (== size 0)
        (store (+ (gpr-or-sp64 rn) offset) (gpr32 rt))
        (store (+ (gpr-or-sp64 rn) offset) (gpr64 rt))))

(def STURB
    "00 111 0 00 00 0 iiiiiiiii 00 nnnnn ttttt"
    "sturb W$rt, [X$rn, #$offset]"
    (names (imm i) (rn n) (rt t))
    (let offset (signext imm i64))
    (store (+ (gpr-or-sp64 rn) offset) (cast (gpr64 rt) u8)))

(def STURH
    "01 111 0 00 00 0 iiiiiiiii 00 nnnnn ttttt"
    "sturh W$rt, [X$rn, #$offset]"
    (names (imm i) (rn n) (rt t))
    (let offset (signext imm i64))
    (store (+ (gpr-or-sp64 rn) offset) (cast (gpr64 rt) u16)))

(def SUB-immediate
    "f 1 0 10001 0s iiiiiiiiiiii nnnnn ddddd"
    "sub $r$rd, $r$rn, #$imm, LSL #$shift"
    (names (size f) (sh s) (imm i) (rd d) (rn n))
    (block
        (let r (if (== size 0) "W" "X"))
        (let shift (if (== sh 0) 0 12))
        (let simm (<< imm shift)))
    (if (== size 0)
        (= (gpr-or-sp32 rd) (- (gpr-or-sp32 rn) simm))
        (= (gpr-or-sp64 rd) (- (gpr-or-sp64 rn) simm))))

(def SUB-extended-register
    "s 1 0 01011 00 1 mmmmm ooo iii nnnnn ddddd"
    "sub $r1$rd, $r1$rn, $r2$rm, $extend #$imm"
    (names (size s) (rm m) (option o) (imm i) (rn n) (rd d))
    (block
        (let r1 (if (== size 0) "W" "X"))
        (let r2 (if (== (& option 0b011) 0b011) "X" "W"))
        (let extend (if (== size 0)
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "LSL"
                0b011 "UXTX"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "UXTW"
                0b011 "LSL"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX"))))
    (if (== size 0)
        (let m (gpr32 rm)
            (= (gpr-or-sp32 rd) (+ (gpr-or-sp32 rn) (~ (<< (match option
                0b000 (& m 0xFF)
                0b001 (& m 0xFFFF)
                0b100 (cast (signext (cast m u8) i32) u32)
                0b101 (cast (signext (cast m u16) i32) u32)
                m) imm)))))
        (if (== (& option 0b011) 0b011)
            (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) (~ (<< (gpr64 rm) imm))))
            (let m (cast (gpr32 rm) u64)
                (= (gpr-or-sp64 rd) (+ (gpr-or-sp64 rn) (~ (<< (match option
                    0b000 (& m 0xFF)
                    0b001 (& m 0xFFFF)
                    0b010 (& m 0xFFFFFFFF)
                    0b100 (cast (signext (cast m u8) i64) u64)
                    0b101 (cast (signext (cast m u16) i64) u64)
                    0b110 (cast (signext m i64) u64)
                    m) imm))))))))

(def SUB-shifted-register
    "f 1 0 01011 ss 0 mmmmm iiiiii nnnnn ddddd"
    "sub $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size f) (shift s) (imm i) (rd d) (rn n) (rm m))
    (block
            (let r (if (== size 0) "W" "X"))
            (let shiftstr (match shift
                0b00 "LSL"
                0b01 "LSR"
                0b10 "ASR"
                (unimplemented))))
    (if (== size 0)
        (let b (gpr32 rm)
            (= (gpr32 rd) (- (gpr32 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i32) imm) u32)
                (unimplemented)))))
        (let b (gpr64 rm)
            (= (gpr64 rd) (- (gpr64 rn) (match shift
                0b00 (<< b imm)
                0b01 (>> b imm)
                0b10 (cast (>> (cast b i64) imm) u64)
                (unimplemented)))))))

(def SUBS-extended-register
    "s 1 1 01011 00 1 mmmmm ooo iii nnnnn ddddd"
    "subs $r$rd, $r$rn, $r2$rm, $extend #$amount"
    (names (size s) (rm m) (option o) (imm i) (rn n) (rd d))
    (block
        (let mode32 (== size 0))
        (let r (if mode32 "W" "X"))
        (let r2 (if (& mode32 (!= (& option 0b011) 0b011)) "W" "X"))
        (let extend (if mode32
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 (if (== rn 31) "LSL" "UXTW")
                0b011 "UXTX"
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")
            (match option
                0b000 "UXTB"
                0b001 "UXTH"
                0b010 "UXTW"
                0b011 (if (== rn 31) "LSL" "UXTX")
                0b100 "SXTB"
                0b101 "SXTH"
                0b110 "SXTW"
                "SXTX")))
        (let amount 0xdead))
    (unimplemented))

(def SUBS-shifted-register
    "s 1 1 01011 hh 0 mmmmm iiiiii nnnnn ddddd"
    "subs $r$rd, $r$rn, $r$rm, $shiftstr #$imm"
    (names (size s) (shift h) (rm m) (imm i) (rn n) (rd d))
    (block
        (let mode32 (== size 0))
        (let r (if mode32 "W" "X"))
        (let shiftstr (match shift
            0b00 "LSL"
            0b01 "LSR"
            0b10 "ASR"
            (unimplemented))))
    (if mode32
        (block
            (let operand1 (gpr32 rn))
            (let operand2 (~ (shift (gpr32 rm) shift imm)))
            (= (gpr32 rd) (add-with-carry-set-nzcv operand1 operand2 1)))
        (block
            (let operand1 (gpr64 rn))
            (let operand2 (~ (shift (gpr64 rm) shift imm)))
            (= (gpr64 rd) (add-with-carry-set-nzcv operand1 operand2 1)))))

(def SUBS-immediate
    "s 1 1 10001 0h iiiiiiiiiiii nnnnn ddddd"
    "subs $r$rd, $r$rn, #$imm, $shiftstr"
    (names (size s) (shift h) (imm i) (rn n) (rd d))
    (block
        (let mode32 (== size 0))
        (let r (if mode32 "W" "X"))
        (let shiftstr (match shift
            0b00 "LSL #0"
            0b01 "LSL #12"
            (unimplemented))))
    (let rimm (if shift (<< imm 12) imm)
        (if mode32
            (block
                (let operand1 (gpr32 rn))
                (let operand2 (~ (cast imm u32)))
                (= (gpr32 rd) (add-with-carry-set-nzcv operand1 operand2 1)))
            (block
                (let operand1 (gpr64 rn))
                (let operand2 (~ (cast imm u64)))
                (= (gpr64 rd) (add-with-carry-set-nzcv operand1 operand2 1))))))

(def SVC
    "11010100 000 iiiiiiiiiiiiiiii 000 01"
    "svc #$imm"
    (names (imm i))
    (block)
    (svc imm))

(def TBZ
    "u 011011 0 bbbbb iiiiiiiiiiiiii ttttt"
    "tbz $r$rt, #$imm, $addr"
    (names (upper u) (bottom b) (offset i) (rt t))
    (block
        (let r (if (== upper 0) "W" "X"))
        (let imm (| (<< upper 5) bottom))
        (let addr (+ (pc) (signext (<< (cast offset u16) 2) i64))))
    (if (== (& (>> (gpr64 rt) imm) 1) 0)
        (branch addr)
        (branch-default)))

(def TBNZ
    "u 011011 1 bbbbb iiiiiiiiiiiiii ttttt"
    "tbnz $r$rt, #$imm, $addr"
    (names (upper u) (bottom b) (offset i) (rt t))
    (block
        (let r (if (== upper 0) "W" "X"))
        (let imm (| (<< upper 5) bottom))
        (let addr (+ (pc) (signext (<< (cast offset u16) 2) i64))))
    (if (!= (& (>> (gpr64 rt) imm) 1) 0)
        (branch addr)
        (branch-default)))

(def UBFM
    "f 10 100110 o pppppp ssssss nnnnn ddddd"
    "ubfm $r$rd, $r$rn, #$immr, #$imms"
    (names (N o) (size f) (immr p) (imms s) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (block
            (let src (gpr32 rn))
            (let wmask (cast (make-wmask N imms immr 0 32) u32))
            (let tmask (cast (make-tmask N imms immr 0 32) u32))
            (let bot (& (>>> src immr) wmask))
            (= (gpr32 rd) (& bot tmask)))
        (block
            (let src (gpr64 rn))
            (let wmask (make-wmask N imms immr 0 64))
            (let tmask (make-tmask N imms immr 0 64))
            (let bot (& (>>> src immr) wmask))
            (= (gpr64 rd) (& bot tmask)))))

(def UDIV
    "f 0 0 11010110 mmmmm 00001 0 nnnnn ddddd"
    "udiv $r$rd, $r$rn, $r$rm"
    (names (size f) (rm m) (rn n) (rd d))
    (let r (if (== size 0) "W" "X"))
    (if (== size 0)
        (let operand2 (gpr32 rm)
            (= (gpr32 rd) (if (== operand2 0)
                (cast 0 u32)
                (cast (/ (cast (gpr32 rn) f32) (cast operand2 f32)) u32))))
        (let operand2 (gpr64 rm)
            (= (gpr64 rd) (if (== operand2 0)
                (cast 0 u64)
                (cast (/ (cast (gpr64 rn) f64) (cast operand2 f64)) u64))))))

(def UMADDL
    "1 00 11011 1 01 mmmmm 0 aaaaa nnnnn ddddd"
    "umaddl X$rd, W$rn, W$rm, X$ra"
    (names (rd d) (rn n) (rm m) (ra a))
    (block)
    (= (gpr64 rd) (+ (gpr64 ra) (* (cast (gpr32 rn) u64) (cast (gpr32 rm) u64)))))

(def UMULH
    "1 00 11011 1 10 mmmmm 0 11111 nnnnn ddddd"
    "umulh X$rd, X$rn, X$rm"
    (names (rm m) (rn n) (rd d))
    (block)
    (= (gpr64 rd) (cast (>> (* (cast (gpr64 rn) u128) (cast (gpr64 rm) u128)) 64) u64)))
